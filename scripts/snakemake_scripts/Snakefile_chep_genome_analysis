import os
docstring=r"""
This is a snakefile. It calculates the SNP heterozygosity of a whole genome,
  as well as the heterozygosities of the exons, genic regions, introns,
  and intergenic regions.

Usage:
 To run the pipeline, give the program chep_genome_analysis at least one argument, like --cores
  chep_genome_analysis --cores 90 -r -p
 To start a dry run to check if the pipeline will work, run
  chep_genome_analysis --cores 90 -r -p -n

Using a VCF file, it also calculates elements of the indel heterozygosity:
  - Per-region indel rate
  - Per-geion SNP rate
  - Size distribution of indels in each region (table and plot)

The required inputs are:
  - A GFF file of genes with introns and exons
  - Genome assembly
  - Illumina forward and reverse reads

Nota bene: the Illumina reads must come from the same individual as the
   reference genome. If this is not true, the results will invalid.

Required software:
  - bwa mem
  - chep software (https://github.com/conchoecia/chep)
  - bedtools
  - bgzip
  - tabix
  - sort
  - uniq
  - column
  - awk

Required python packages
  - python 3
  - seaborn
  - matplotlib
  - pandas
"""

if "help" in config:
    print(docstring)
    os._exit(0)

if 999999999 not in config["WINDOWS"]:
    config["WINDOWS"].append(999999999)

bamstem = config["BAM"].split("/")[-1].replace(".bam", "")

import pandas as pd
from Bio import SeqIO

def get_number_from_file(filepath):
    with open(filepath, "r") as f:
        for line in f:
            line = line.strip()
            if line:
                return(int(line))

if "MINCHROMLEN" not in config:
    config["MINCHROMLEN"] = 100000
if "REF" in config:
    # get all the chromosomes
    chroms = {}
    if not os.path.exists(config["REF"]):
        raise IOError("{} does not exist".format(config["REF"]))
    with open(config["REF"], "rU") as handle:
        for record in SeqIO.parse(handle, "fasta"):
            if len(record.seq) >= config["MINCHROMLEN"]:
                key ="".join([x for x in str(record.id) if x not in ["_", ".",
                  ",", "!", "#", "$", "%", "^", "&", "(", ")", "-", "+", "~",
                  "`", "@", "*", "{", "}", "|", "\\", ":", ";", "'", "\"",
                  "<", ">", "/", "?"]])
                if key in chroms:
                    raise IOError("This sequence's ID clashes with other in fasta: {}, {}".format(record.id, chroms[key]))
                chroms[key] = str(record.id)


rule all:
    input:
        # get all the bed files
        expand("het_output/bed/{prefix}_{region}.bed", prefix=config["PREFIX"],
               region = ["wholeGenome", "exonic", "genic",
                         "intergenic", "intronic", "noncoding"]),
        # pileup tables
        expand("het_output/pileup_tables/{prefix}_{region}_pileup_table.txt",
               prefix=config["PREFIX"], region = ["wholeGenome", "exonic", "genic",
                         "intergenic", "intronic", "noncoding"]),
        # make the plots
        expand("het_output/plots/{prefix}_{region}_marginal_het_het_plot.pdf",
               prefix=config["PREFIX"], region = ["wholeGenome", "exonic", "genic",
                                        "intergenic", "intronic", "noncoding"]),
        expand("het_output/plots/{prefix}_{region}_het_by_position.tsv",
               prefix=config["PREFIX"], region = ["wholeGenome", "exonic", "genic",
                                        "intergenic", "intronic", "noncoding"]),
        #get a diploid, gzipped vcf file
        expand("het_output/vcf/{prefix}_diploid.vcf.gz", prefix=config["PREFIX"]),
        # get the region snp and indel counts
        # make a table of the indel spectrum - makes a plot of size dist per region and a simple boxplot
        expand("het_output/counts/snp_by_region/{prefix}_{region}_snp_count.txt",
               prefix=config["PREFIX"], region = ["wholeGenome", "exonic", "genic",
                                        "intergenic", "intronic", "noncoding"]),
        expand("het_output/counts/indel_spec_by_region/{prefix}_{region}_indel_spec.txt",
               prefix=config["PREFIX"], region = ["wholeGenome", "exonic", "genic",
                                        "intergenic", "intronic", "noncoding"]),
        expand("het_output/counts/indel_by_region/{prefix}_{region}_indel_count.txt",
               prefix=config["PREFIX"], region = ["wholeGenome", "exonic", "genic",
                                        "intergenic", "intronic", "noncoding"]),
        expand("het_output/counts/indel_spec_by_region/{prefix}_all_indel_spec.txt", prefix=config["PREFIX"]),
        expand("het_output/plots/{prefix}_all_indel_spec.pdf", prefix=config["PREFIX"]),
        expand("het_output/plots/{prefix}_indel_size_distribution.pdf", prefix=config["PREFIX"]),
        expand("het_output/counts/tables/{prefix}_indel_SNP_rate_table.txt", prefix=config["PREFIX"]),

        # now do the analyses over windows
        expand("het_output/window/merged/{prefix}_w{window}_{region}_all_het.tsv",
               prefix=config["PREFIX"], window=config["WINDOWS"],
               region = ["exonic", "genic", "intergenic", "intronic", "noncoding"]),
        expand("het_output/counts/tables/by_chr/{prefix}_indel_SNP_by_{region}.txt",
               prefix=config["PREFIX"], region = ["exonic", "genic", "intergenic", "intronic", "noncoding"]),
        expand("het_output/counts/tables/window/{prefix}_w{window}_VCF_indel_snp_rates_{region}.txt",
               window=config["WINDOWS"], prefix=config["PREFIX"],
               region = ["exonic", "genic", "intergenic", "intronic", "noncoding"]),
        expand("het_output/final_output/tables/{prefix}_w{window}_indel_snp.tsv",
               window=config["WINDOWS"], prefix=config["PREFIX"]),

        # final PDF plots
        expand("het_output/final_output/pdf/pairplot/{prefix}_w{window}_pairplot.pdf", window=config["WINDOWS"], prefix=config["PREFIX"]),
        expand("het_output/final_output/pdf/{prefix}_depth_histo_plot.pdf", prefix=config["PREFIX"]),
        expand("het_output/final_output/pdf/{prefix}_depth_histo_plot_single.pdf", prefix=config["PREFIX"]),
        expand("het_output/final_output/pdf/snp_vs_indel/{prefix}_w{window}_snpvindel.pdf",
               window=config["WINDOWS"], prefix=config["PREFIX"]),
        expand("het_output/final_output/pdf/snp_vs_indel/{prefix}_w{window}_snpvindel_labels.pdf",
               window=config["WINDOWS"], prefix=config["PREFIX"]),
        expand("het_output/final_output/pdf/chrom_pos_value/{prefix}_w{window}_chrom_pos_value.pdf",
               window=[x for x in config["WINDOWS"] if x != 999999999], prefix=config["PREFIX"])

region_palette = palette={"wholeGenome": "#000000", "exonic": "#3a8ac1",
                          "intergenic": "#d1bb3a", "intronic": "#981e48"}


rule print_help:
    run:
        print(__doc__)

rule index_the_bam_file:
    input:
        bam = config["BAM"]
    output:
        bai = "{}.bai".format(config["BAM"])
    params: 1
    shell:
        """
        samtools index {input.bam}
        """

rule get_bed_files:
    input:
        gff = config["GFF"],
        ref = config["REF"]
    output:
        exonic       = "het_output/bed/{prefix}_exonic.bed",
        genic        = "het_output/bed/{prefix}_genic.bed",
        intergenic   = "het_output/bed/{prefix}_intergenic.bed",
        intronic     = "het_output/bed/{prefix}_intronic.bed",
        noncoding    = "het_output/bed/{prefix}_noncoding.bed",
        wholeGenome  = "het_output/bed/{prefix}_wholeGenome.bed",
        stats        = "het_output/bed/{prefix}_genome_stats.txt",
        genfile      = "het_output/bed/{prefix}_size_wholeGenome.genfile"

    params:
        prefix = lambda wildcards: wildcards.prefix
    threads: 1
    shell:
        """
        #get all the bed files
        chep_gff2all het_output/bed/{params.prefix} {input.ref} {input.gff}
        """

# CHEP BASIC PLOT
rule chep_depth_v_ref_by_region:
    """
    this generates the chep depth_v_ref table used later to make the chep
      plot.
    """
    input:
        bam = config["BAM"],
        bai = "{}.bai".format(config["BAM"]),
        bed= "het_output/bed/{prefix}_{region}.bed",
        ref = config["REF"]
    output:
        txt = "het_output/pileup_tables/{prefix}_{region}_pileup_table.txt"
    shell:
        """
        samtools mpileup -f {input.ref} -l {input.bed} {input.bam} | \
          chep_pileup_to_array > {output.txt}
        """

# CHEP BASIC PLOT
rule plot_results:
    input:
        table = "het_output/pileup_tables/{prefix}_{region}_pileup_table.txt",
        ref = config["REF"]
    output:
        pdf = "het_output/plots/{prefix}_{region}_marginal_het_het_plot.pdf",
        tsv = "het_output/plots/{prefix}_{region}_het_by_position.tsv"
    threads: 1
    params:
        outprefix = lambda wildcards: "het_output/plots/{}_{}".format(wildcards.prefix, wildcards.region),
        xmin = config["XMIN"],
        xmax = config["XMAX"]
    shell:
        """
        chep_plot -o {params.outprefix} -g {input.ref} -x {params.xmin} -X {params.xmax} -f {input.table}
        """
# CHEP RESULTS STOP

rule gzipped_diploid_vcf:
    input:
        vcf = config["VCF"]
    output:
        gz = "het_output/vcf/{prefix}_diploid.vcf.gz",
        tbi = "het_output/vcf/{prefix}_diploid.vcf.gz.tbi",
    threads: 1
    shell:
        """
        CATTYPE="cat"
        if [[ {input.vcf} =~ \.gz$ ]];
        then
            CATTYPE="zcat"
            echo "inside gz CATTYPE is ${{CATTYPE}}"
        elif [[ {input.vcf} = \.vcf$ ]];
        then
            CATTYPE="cat"
            echo "inside vcf CATTYPE is ${{CATTYPE}}"
        else
            echo "vcf file must be .vcf or .gz"
            exit 1
        fi
        echo "CATTYPE is ${{CATTYPE}}"
        ${{CATTYPE}} {input.vcf} | grep '##' > temp.vcf
        ${{CATTYPE}} {input.vcf} | grep -v '##' | awk '$5 !~ ","' >> temp.vcf
        bgzip -c temp.vcf > {output.gz}
        tabix -p vcf {output.gz}
        rm temp.vcf
        """

# PLOTTING INDEL DISTRIBUTION
rule calc_indel_raw_for_region:
    """
    This outputs a file of the raw counts of indel size taken from the vcf file.
    This file is later used to make a plot of the distribution of indel sizes
     regions are probably whole-genome, exonic, intronic, intergenic.
    """
    input:
        bed = "het_output/bed/{prefix}_{region}.bed",
        gz =  "het_output/vcf/{prefix}_diploid.vcf.gz",
        tbi = "het_output/vcf/{prefix}_diploid.vcf.gz.tbi"
    output:
         table = "het_output/counts/indel_raw_by_region/{prefix}_{region}_indel_raw.txt"
    threads: 1
    shell:
        """
        bedtools intersect -a {input.gz} -b {input.bed} | \
          awk 'function abs(x){{return ((x < 0.0) ? -x : x)}} \
               {{print(abs(length($5)-length($4)))}}' | \
          grep -v '0' > {output.table}
        """

# PLOTTING INDEL DISTRIBUTION
rule calc_indel_spectrum_for_region:
    """
    This calculates a spectrum of the indel size, used downstream in the plot
    of the indel distribution in different regions.
    """
    input:
        table = "het_output/counts/indel_raw_by_region/{prefix}_{region}_indel_raw.txt"
    output:
        table = "het_output/counts/indel_spec_by_region/{prefix}_{region}_indel_spec.txt"
    threads: 1
    shell:
        """
        cat {input.table} | sort | uniq -c | column -t | sort -k2 -n > {output.table}
        """

# PLOTTING INDEL DISTRIBUTION
rule calc_indel_number_for_region:
    """
    simple count of the number of indels in a region.
    Does it for the whole region in the whole genome
    """
    input:
        table = "het_output/counts/indel_spec_by_region/{prefix}_{region}_indel_spec.txt"
    output:
         table = "het_output/counts/indel_by_region/{prefix}_{region}_indel_count.txt"
    threads: 1
    shell:
        """
        awk '{{sum = sum + $1}} END{{print(sum)}}' {input.table} > {output.table}
        """

# PLOTTING INDEL DISTRIBUTION
rule calc_snp_number_for_region:
    """
    count of the number of SNPs per region using the VCF. Not super accurate.
    """
    input:
        bed = "het_output/bed/{prefix}_{region}.bed",
        dipvcfgz =  "het_output/vcf/{prefix}_diploid.vcf.gz",
        tbi = "het_output/vcf/{prefix}_diploid.vcf.gz.tbi"
    output:
         table = "het_output/counts/snp_by_region/{prefix}_{region}_snp_count.txt"
    threads: 1
    shell:
        """
        bedtools intersect -a {input.dipvcfgz} -b {input.bed} | \
          awk '{{if (length($4) == length($5)){{print($0)}}}}' | wc -l > {output.table}
        """

# PLOTTING INDEL DISTRIBUTION
rule indel_spectrum_to_joint_spectrum:
    """
    Turns the individual region spectra into a single file.
    The single file has the original spetra, and frequency-adjusted spectra.

    This file is then used to make the final plot of indel size distribution
    """
    input:
        stats = "het_output/bed/{prefix}_genome_stats.txt",
        tables = expand("het_output/counts/indel_spec_by_region/{prefix}_{region}_indel_spec.txt",               
                 prefix=config["PREFIX"], region = ["wholeGenome", "exonic", "genic",
                                        "intergenic", "intronic", "noncoding"])
    output:
        table = "het_output/counts/indel_spec_by_region/{prefix}_all_indel_spec.txt"
    params:
        prefix = lambda wildcards: wildcards.prefix,
        regions = ["wholeGenome", "exonic", "genic",
                   "intergenic", "intronic", "noncoding"]
    threads: 1
    run:
        region_to_num_bases = {}
        wholeGenome_size = 0
        with open(input.stats, "r") as f:
            for line in f:
                line = line.strip()
                if line[0] == '#':
                    wholeGenome_size = int(line.split(":")[1])
                else:
                    splitd = line.split()
                    if splitd[0] != "region" and splitd[0] in params.regions:
                        region_to_num_bases[splitd[0]] = int(splitd[1])
        # now make the table
        cols = []
        dict_list = []
        for region in region_to_num_bases:
            #print(region)
            parse_file = "het_output/counts/indel_spec_by_region/{}_{}_indel_spec.txt".format(params.prefix, region)
            cols.append(region)
            dict_list.append({})
            #print(parse_file)
            #print(os.path.exists(parse_file))
            with open(parse_file, "r") as f:
                for line in f:
                    line=line.strip()
                    if line:
                        splitd=line.split()
                        count=int(splitd[0])
                        index=int(splitd[1])
                        dict_list[-1][index]=count
        df = pd.DataFrame.from_records(dict_list).T
        df.columns = cols
        df = df.fillna(0).astype(int)
        for key in cols:
            df["{}_frequency".format(key)] = df[key]/region_to_num_bases[key]
        df.to_csv(output.table, sep='\t', index_label = "indel_size")

# PLOTTING INDEL DISTRIBUTION
rule joint_spectrum_to_frequency_plot:
    """
    makes a plot of the frequency of indels in different genomic regions
    """
    input:
        table = "het_output/counts/indel_spec_by_region/{prefix}_all_indel_spec.txt"
    output:
        pdf = "het_output/plots/{prefix}_all_indel_spec.pdf"
    threads: 1
    run:
        import pandas as pd
        import seaborn as sns; sns.set()
        import matplotlib
        import matplotlib.pyplot as plt
        from matplotlib.ticker import StrMethodFormatter, NullFormatter
        import numpy as np
        # set seaborn stuff
        #sns.set(rc={'text.usetex' : True})
        sns.set_style("white", {'font.family': ['sans-serif'],
                                    'font.sans-serif': ['Helvetica'],
                                    'grid.color': '.95'})

        # Preserve the vertical order of embedded images:
        matplotlib.rcParams['image.composite_image'] = False
        matplotlib.rcParams['pdf.fonttype'] = 42
        matplotlib.rcParams['ps.fonttype'] = 42

        df = pd.read_csv(input.table, header=0, sep='\t')
        cols = ["indel_size", "exonic_frequency", "intergenic_frequency", "intronic_frequency"]
        plotdf = df[cols]
        newdf = plotdf.melt("indel_size", var_name="cols", value_name="vals")
        newdf2 = newdf.loc[newdf["cols"].str.contains("frequency"),]
        ax = sns.scatterplot(x="indel_size", y="vals", hue="cols",
                             alpha=0.5, linewidth=0, data=newdf2)
        ax.set_xscale("log")
        ax.set(ylim=(0, max(newdf2["vals"])*1.1))
        ax.set(xlim=(0, 25))
        plt.xlabel("indel_size")
        plt.ylabel("Frequency")
        figure = ax.get_figure()
        figure.savefig(output.pdf)

#INDEL SIZE DISTRIBUTION BOXPLOT
rule plot_indel_size_distribution:
    """
    This takes all the raw size counts of the different genomic regions and
     makes a boxplot.
    """
    input:
         table = expand("het_output/counts/indel_raw_by_region/{prefix}_{region}_indel_raw.txt",
                 prefix=config["PREFIX"], region = ["wholeGenome", "exonic", "genic",
                                        "intergenic", "intronic", "noncoding"])
    output:
        pdf = "het_output/plots/{prefix}_indel_size_distribution.pdf"
    params:
        prefix = lambda wildcards: wildcards.prefix
    threads: 1
    run:
        import pandas as pd
        import seaborn as sns; sns.set()
        import matplotlib
        import matplotlib.pyplot as plt
        from matplotlib.ticker import StrMethodFormatter, NullFormatter
        import numpy as np

        # set seaborn stuff
        #sns.set(rc={'text.usetex' : True})
        sns.set_style("white", {'font.family': ['sans-serif'],
                                    'font.sans-serif': ['Helvetica'],
                                    'grid.color': '.95'})
        # Preserve the vertical order of embedded images:
        matplotlib.rcParams['image.composite_image'] = False
        matplotlib.rcParams['pdf.fonttype'] = 42
        matplotlib.rcParams['ps.fonttype'] = 42

        cols = ["exonic", "intergenic", "intronic"]
        #cols = ["exonic", "intergenic", "intronic", "genic", "noncoding", "wholeGenome"]

        observations = []
        kind = []

        for thiskey in cols:
            filepath = "het_output/counts/indel_raw_by_region/{}_{}_indel_raw.txt".format(params.prefix, thiskey)
            df = pd.read_csv(filepath, header=None)
            for x in list(df[0]):
                observations.append(x)
                kind.append(thiskey)

        df = pd.DataFrame(list(zip(observations, kind)),
                       columns =['indel_size', 'type'])
        df["indel_size_log"] = np.log(df["indel_size"])
        ax = sns.boxplot(x="type", y="indel_size_log", data=df)
        tl = ax.get_yticks()
        ticks = [tl[i] for i in range(len(tl))][1::]
        tick_vals = [int(np.exp(y)) for y in ticks]
        ax.set_yticks(ticks)
        ax.set_yticklabels(tick_vals)
        plt.ylabel("Indel Size (bp)")
        figure = ax.get_figure()
        figure.savefig(output.pdf)

# BAD
rule table_of_indel_and_SNP_rates:
    """
    nothing downstream uses this. This isn't great because it measures the SNP
      rate simply by dividing the number of SNPs by the region size
    """
    input:
        snp    = expand("het_output/counts/snp_by_region/{prefix}_{region}_snp_count.txt",
                 prefix=config["PREFIX"], region = ["wholeGenome", "exonic", "genic",
                                        "intergenic", "intronic", "noncoding"]),
        indel  = expand("het_output/counts/indel_by_region/{prefix}_{region}_indel_count.txt",
                 prefix=config["PREFIX"], region = ["wholeGenome", "exonic", "genic",
                                        "intergenic", "intronic", "noncoding"]),
        tables = expand("het_output/pileup_tables/{prefix}_{region}_pileup_table.txt",
                 prefix=config["PREFIX"], region = ["wholeGenome", "exonic", "genic",
                                        "intergenic", "intronic", "noncoding"]),
        stats  = "het_output/bed/{prefix}_genome_stats.txt",
    output:
        table = "het_output/counts/tables/{prefix}_indel_SNP_rate_table.txt"
    params:
        prefix = lambda wildcards: wildcards.prefix,
        depth = config["HAPDEPTH"],
        regions = ["wholeGenome", "exonic", "genic",
                   "intergenic", "intronic", "noncoding"]
    threads: 1
    run:
        import pandas as pd
        #pd.set_option('display.float_format', lambda x: '%.9f' % x)
        region_info = {}
        wholeGenome_size = 0
        with open(input.stats, "r") as f:
            for line in f:
                line = line.strip()
                if line:
                    if line[0] == '#':
                        wholeGenome_size = int(line.split(":")[1])
                    else:
                        splitd = line.split()
                        if splitd[0] != "region" and splitd[0] in params.regions:
                            thisregion = splitd[0]
                            region_size = int(splitd[1])
                            region_info[thisregion] = {"region_size": region_size}
        region_info["wholeGenome"] = {"region_size": wholeGenome_size}

        # add the snp info
        for this_region in params.regions:
            filepath = "het_output/counts/snp_by_region/{}_{}_snp_count.txt".format(params.prefix, this_region)
            region_info[this_region]["snp_count"] = get_number_from_file(filepath)
            filepath = "het_output/counts/indel_by_region/{}_{}_indel_count.txt".format(params.prefix, this_region)
            region_info[this_region]["indel_count"] = get_number_from_file(filepath)

        # now get the calculated region heterozygosity
        for this_region in params.regions:
            filepath = "het_output/plots/{}_{}_het_by_position.tsv".format(params.prefix, this_region)
            df = pd.read_csv(filepath, sep='\t', header=0)
            het = float(df.loc[df["depth"] == params.depth, "5flank_het"])
            region_info[this_region]["5flank_het"] = het
        outdf = pd.DataFrame.from_records(region_info).T
        outdf["snp_percent"] = 100*(outdf["snp_count"]/outdf["region_size"])
        outdf["indel_percent"] = 100*(outdf["indel_count"]/outdf["region_size"])
        #df.to_csv(output.table, sep='\t', index_label = "indel_size")
        outdf.to_csv(output.table, index_label = "region", sep='\t')

rule split_the_bam_files:
    """
    this splits the bam file into its constitutive chromosomes to speed up parallelization
      later
    """
    input:
        bam = config["BAM"],
        bai = "{}.bai".format(config["BAM"])
    output:
        bam = "bams/{prefix}_{chrom}.bam"
    threads: workflow.cores * 0.25
    params:
        chromreal = lambda wildcards: chroms[wildcards.chrom]
    shell:
        """
        samtools view -hb -@ {threads} {input.bam} {params.chromreal} | \
          samtools sort -@ {threads} - > {output.bam}
        """

rule per_windowed_het:
    """This step parallelizes the heterozygosity calculations on a per-chromosome
       basis. These results can be collated together later on.
    """
    input:
        ref = config["REF"],
        bed = "het_output/bed/{prefix}_{region}.bed",
        bam = "bams/{prefix}_{chrom}.bam"
    output:
        het = "het_output/window/table/window_{window}/{prefix}_{chrom}_{region}_windowed_het.tsv"
    params:
        flank  = config["FLANK"],
        peak   = config["HAPDEPTH"],
        window = lambda wildcards: wildcards.window,
        chrom = lambda wildcards: chroms[wildcards.chrom]
    threads: 1
    shell:
        """
        cat {input.bed} | \
         awk '{{if($1=="{params.chrom}"){{print($0)}}}}' | \
         samtools mpileup -f {input.ref} -l /dev/fd/0 {input.bam} | \
         chep_windowed_het -f {params.flank} \
         -p {params.peak} -w {params.window} > {output.het}
        """

rule merge_windowed_het:
    """This takes the output of the parallelized windowed heterozygosity
    analysis and turns it into a single file that is easy to parse."""
    input:
        het_files = expand("het_output/window/table/window_{{window}}/{{prefix}}_{chrom}_{{region}}_windowed_het.tsv",
                           chrom = chroms)
    output:
        collapsed = "het_output/window/merged/{prefix}_w{window}_{region}_all_het.tsv"
    threads: 1
    run:
        printthis = open(output.collapsed, "w")
        for i in range(len(input.het_files)):
            with open(input.het_files[i]) as f:
                for line in f:
                    line = line.strip()
                    if i == 0:
                        print(line, file=printthis)
                    else:
                        if line[0] != '#' and "num_sites_mes" not in line:
                            print(line, file=printthis)
        printthis.close()

rule per_region_indel_snp_table:
    """
    Makes a special table that includes whether a position in the region is an
    Indel or a SNP
    """
    input:
        bed = "het_output/bed/{prefix}_{region}.bed",
        vcf = "het_output/vcf/{prefix}_diploid.vcf.gz",
    output:
        txt = "het_output/counts/tables/by_chr/{prefix}_indel_SNP_by_{region}.txt"
    threads: 1
    shell:
        """
        bedtools intersect -a {input.vcf} -b {input.bed} | \
          awk '{{ if (length($4) != length($5)){{ \
                      printf("%s\\t%d\\tI\\n",$1,$2) \
                  }} \
                  else if ( length($4) == length($5) ) {{ \
                       printf("%s\\t%d\\tS\\n",$1,$2) \
                  }} \
               }}' > {output.txt}
        """

rule per_chromosome_per_region_windowed_indel_stats:
    """
    Makes a special table that includes whether a position in the region is an
    Indel or a SNP
    """
    input:
        bed = "het_output/bed/{prefix}_{region}.bed",
        txt = "het_output/counts/tables/by_chr/{prefix}_indel_SNP_by_{region}.txt"
    output:
        txt = "het_output/counts/tables/window/{prefix}_w{window}_VCF_indel_snp_rates_{region}.txt"
    params:
        window = lambda wildcards: wildcards.window,
        region = lambda wildcards: wildcards.region
    threads: 1
    run:
        # read in the the table of snps and indels
        df = pd.read_csv(input.txt, sep="\t", header = None)
        df.columns = ["chrom", "pos", "type"]
        IR = pd.interval_range(start=0, freq=int(params.window), end=999999999, closed='right')

        # make a table with the number of indels in the region
        dfI = df.loc[df["type"] == "I"]
        dfI = dfI[["chrom", "pos"]]
        dfI_groups = dfI.groupby(['chrom', pd.cut(dfI.pos, IR)]).size().to_frame("size").reset_index()
        dfI_groups.columns = ["chrom", "pos", "VCF_Indel_count"]

        # make a table with the number of SNPs in the region
        dfS = df.loc[df["type"] == "S"]
        dfS = dfS[["chrom", "pos"]]
        dfS_groups = dfS.groupby(['chrom', pd.cut(dfS.pos, IR)]).size().to_frame("size").reset_index()
        dfS_groups.columns = ["chrom", "pos", "VCF_SNP_count"]

        # merge SNPs and indels
        dfMerge = pd.merge(dfI_groups, dfS_groups)

        # open the bed file
        beddf = pd.read_csv(input.bed, sep="\t", header = None)
        beddf.columns = ["chrom", "start", "stop"]
        beddf2 = pd.concat([pd.DataFrame(
            {"pos": pd.RangeIndex(row["start"], row["stop"]+1),
             "chrom": row["chrom"]
             }                  )
                for i,row in beddf.iterrows()
                   ], ignore_index=True)
        dfA_groups = beddf2.groupby(['chrom', pd.cut(beddf2.pos, IR)]).size().to_frame("size").reset_index()
        dfA_groups.columns = ["chrom", "pos", "VCF_All_count"]

        dfMerge2 = pd.merge(dfMerge, dfA_groups, on=["chrom", "pos"])
        dfMerge2["targ_start"] = dfMerge2['pos'].apply(lambda x: x.left + 1)
        dfMerge2["targ_stop"] = dfMerge2['pos'].apply(lambda x: x.right)
        dfMerge2 = dfMerge2[[x for x in dfMerge2.columns if x != "pos"]]
        dfMerge2["VCF_per_SNP"] = (dfMerge2["VCF_SNP_count"]/dfMerge2["VCF_All_count"]) * 100
        dfMerge2["VCF_per_Indel"] = (dfMerge2["VCF_Indel_count"]/dfMerge2["VCF_All_count"]) * 100
        dfMerge2["region"] = params.region
        dfMerge2.to_csv(output.txt, index=False, sep='\t')

rule make_table_of_per_chromosome_het_site_types:
    input:
        vcf = expand("het_output/counts/tables/window/{{prefix}}_w{{window}}_VCF_indel_snp_rates_{region}.txt",
               region = ["exonic", "genic", "intergenic",
                         "intronic", "noncoding"]),
        chep = expand("het_output/window/merged/{{prefix}}_w{{window}}_{region}_all_het.tsv",
               region = ["exonic", "genic", "intergenic",
                         "intronic", "noncoding"]),
    output:
        per_chr_txt = "het_output/final_output/tables/{prefix}_w{window}_indel_snp.tsv"
    params:
        regions = ["exonic", "genic", "intergenic", "intronic", "noncoding"],
        prefix = lambda wildcards: wildcards.prefix,
        window = lambda wildcards: wildcards.window
    threads: 1
    run:
        # First open each of the spreadsheets
        all_regions = []
        for region in params.regions:
            vcffile = "het_output/counts/tables/window/{p}_w{w}_VCF_indel_snp_rates_{r}.txt".format(
                    p = params.prefix, w = params.window, r = region)
            vcf_df = pd.read_csv(vcffile, sep = "\t", header =0)
            vcf_df["region"] = region

            chepfile = "het_output/window/merged/{p}_w{w}_{r}_all_het.tsv".format(
                    p = params.prefix, w = params.window, r = region)
            chep_df = pd.read_csv(chepfile, sep = "\t", header =0, comment ='#')
            chep_df["region"] = region
            mergedf = pd.merge(chep_df, vcf_df, on=["chrom", "targ_start", "targ_stop", "region"])
            all_regions.append(mergedf)
        save_this = pd.concat(all_regions)
        save_this.to_csv(output.per_chr_txt, index=False, sep='\t')

# PLOTS
rule plot_several_read_depth_histograms:
    """
    plots read depth histograms from several genomic regions
    """
    input:
        hbp = expand("het_output/plots/{{prefix}}_{region}_het_by_position.tsv",
               region = ["wholeGenome", "intronic", "intergenic", "exonic"])
    output:
        pdf = "het_output/final_output/pdf/{prefix}_depth_histo_plot.pdf"
    params:
        regions = ["wholeGenome", "intronic", "intergenic", "exonic"]
    threads: 1
    run:
        import matplotlib
        import matplotlib.pyplot as plt
        from matplotlib.ticker import StrMethodFormatter, NullFormatter
        # Preserve the vertical order of embedded images:
        matplotlib.rcParams['image.composite_image'] = False
        matplotlib.rcParams['pdf.fonttype'] = 42
        matplotlib.rcParams['ps.fonttype'] = 42

        # Now plot the normalized scaffold N50 and contigN50
        #set the figure dimensions
        figWidth = 3
        figHeight = 4
        fig = plt.figure(figsize=(figWidth,figHeight))
        #set the panel dimensions
        margincount = len(params.regions) + 3
        marginper = 0.25
        marginheight = (figHeight*marginper)/margincount
        panelWidth = 1.75
        panelHeight = (figHeight - (figHeight*marginper))/len(params.regions)

        panels = []
        xpos = (figWidth*0.5)/2
        ypos = marginheight
        leftMargin = xpos
        bottomMargin = ypos * 3
        for i in range(len(params.regions)):
            thisregion = params.regions[i]
            #find the margins to center the panel in figure
            print(leftMargin, bottomMargin)
            panels.append(plt.axes([leftMargin/figWidth, #left
                               bottomMargin/figHeight,    #bottom
                               panelWidth/figWidth,   #width
                               panelHeight/figHeight])     #height
                               )
            #panels.append(ax)
            if i == 0:
                panels[i].tick_params(axis='both',which='both',\
                              bottom=True, labelbottom=True,\
                              left=True, labelleft=True, \
                              right=False, labelright=False,\
                              top=False, labeltop=False)
                plt.xlabel("mapping depth")
            else:
                panels[i].tick_params(axis='both',which='both',\
                      bottom=False, labelbottom=False,\
                      left=True, labelleft=True, \
                      right=False, labelright=False,\
                      top=False, labeltop=False)

            bottomMargin = bottomMargin + panelHeight + marginheight
            open_this = input.hbp[i]
            df = pd.read_csv(open_this, header=0, sep="\t")
            panels[i].plot(df["depth"], df["totdepth"]/1000, mfc ="black", mew=0,
                    marker='o', linewidth=0, markersize=1)
            panels[i].yaxis.set_label_position("right")
            panels[i].set_ylabel(thisregion)
        fig.text(0.07, 0.25, "Kbp at this map depth", ha='center', rotation = 90)
        plt.tight_layout()
        fig.savefig(output.pdf)

rule plot_read_depth_histograms_one_area:
    """
    plots read depth histograms from several genomic regions
    plots everything in a single box
    """
    input:
        hbp = expand("het_output/plots/{{prefix}}_{region}_het_by_position.tsv",
               region = ["wholeGenome", "intronic", "intergenic", "exonic"])
    output:
        pdf = "het_output/final_output/pdf/{prefix}_depth_histo_plot_single.pdf"
    params:
        regions = ["wholeGenome", "intronic", "intergenic", "exonic"]
    threads: 1
    run:
        import seaborn as sns; sns.set()
        import matplotlib
        import matplotlib.pyplot as plt
        from matplotlib.ticker import StrMethodFormatter, NullFormatter
        sns.set_style("ticks", {'font.family': ['sans-serif'],
                                    'font.sans-serif': ['Helvetica'],
                                    'grid.color': '.95'})
        # Preserve the vertical order of embedded images:
        matplotlib.rcParams['image.composite_image'] = False
        matplotlib.rcParams['pdf.fonttype'] = 42
        matplotlib.rcParams['ps.fonttype'] = 42

        # Now plot the normalized scaffold N50 and contigN50
        #set the figure dimensions
        figWidth = 3
        figHeight = 3
        fig = plt.figure(figsize=(figWidth,figHeight))
        #set the panel dimensions

        df_list = []
        for i in range(len(params.regions)):
            thisregion = params.regions[i]
            open_this = input.hbp[i]
            df = pd.read_csv(open_this, header=0, sep="\t")
            df= df[["depth", "totdepth"]]
            df["totdepth"] = df["totdepth"]/1000000
            df["region"] = params.regions[i]
            df_list.append(df)
        plot_this = pd.concat(df_list)
        region_palette = palette={"wholeGenome": "#000000", "exonic": "#3a8ac1",
                                  "intergenic": "#d1bb3a", "intronic": "#981e48"}
        ax = sns.scatterplot(x="depth", y="totdepth",
                             hue="region",data=plot_this,
                             alpha=0.1, edgecolor="none",
                             palette=region_palette,
                             style="region",
                             markers =["^", "o", "o", "o"],
                             size = "region",
                             sizes = [10,25,25,25])
        fig = ax.get_figure()
        fig.savefig(output.pdf)

rule plot_indel_vs_het:
    """
    plots the indel rate vs the het rate
    """
    input:
        hbp = "het_output/final_output/tables/{prefix}_w{window}_indel_snp.tsv"
    output:
        pdf = "het_output/final_output/pdf/snp_vs_indel/{prefix}_w{window}_snpvindel.pdf",
        pdf2 = "het_output/final_output/pdf/snp_vs_indel/{prefix}_w{window}_snpvindel_labels.pdf"
    threads: 1
    run:
        import seaborn as sns; sns.set()
        import matplotlib
        import matplotlib.pyplot as plt
        from matplotlib.ticker import StrMethodFormatter, NullFormatter
        sns.set_style("ticks", {'font.family': ['sans-serif'],
                                    'font.sans-serif': ['Helvetica'],
                                    'grid.color': '.95'})
        # Preserve the vertical order of embedded images:
        matplotlib.rcParams['image.composite_image'] = False
        matplotlib.rcParams['pdf.fonttype'] = 42
        matplotlib.rcParams['ps.fonttype'] = 42

        df = pd.read_csv(input.hbp, header=0, sep='\t', comment='#')
        df = df.loc[df["region"].isin(["exonic", "intronic", "intergenic"])]
        df = df.loc[df["chrom"].isin(["c{}".format(x) for x in range(1,14)])]

        for i in range(0,2):
            figWidth = 2.5
            figHeight = 2.5
            xaxis = "per_indel_bases"
            yaxis = "het"
            fig = plt.figure(figsize=(figWidth,figHeight))
            ax = sns.scatterplot(x=xaxis, y=yaxis,
                                 hue="region",data=df,
                                 alpha=0.5, edgecolor="none",
                                 palette=region_palette, legend =False)
            ymin = max(min(df[yaxis])*0.8, 0)
            ymax = max(df[yaxis]*1.1)
            ax.set(ylim=(ymin, ymax))
            xmin = min(df[xaxis])*0.6
            xmax = max(df[xaxis]*1.1)
            ax.set(xlim=(xmin, xmax))

            if i == 1:
                ymin, ymax = ax.get_ylim()
                color="#3498db" # choose a color
                bonus = (ymax - ymin) / 50 # still hard coded bonus but scales with the data
                for x, y, name in zip(df[xaxis], df[yaxis], df["chrom"]):
                    ax.text(x, y + bonus, name, color="black", size=6)
                #fig = ax.get_figure()
                fig.savefig(output.pdf2)
            else:
                fig.savefig(output.pdf)

rule plot_chrom_values_windows:
    """
    plots the het rates, vcf, gc, and more along each chromosome
    """
    input:
        genfile = "het_output/bed/{prefix}_size_wholeGenome.genfile",
        hbp = "het_output/final_output/tables/{prefix}_w{window}_indel_snp.tsv"
    output:
        pdf = "het_output/final_output/pdf/chrom_pos_value/{prefix}_w{window}_chrom_pos_value.pdf",
    threads: 1
    run:
        import seaborn as sns; sns.set()
        import matplotlib
        import matplotlib.pyplot as plt
        import matplotlib.ticker as ticker
        from matplotlib.ticker import StrMethodFormatter, NullFormatter

        # set seaborn stuff
        #sns.set(rc={'text.usetex' : True})
        sns.set_style("white", {'font.family': ['sans-serif'],
                                    'font.sans-serif': ['Helvetica'],
                                    'grid.color': '.95'})

        # Preserve the vertical order of embedded images:
        matplotlib.rcParams['image.composite_image'] = False
        matplotlib.rcParams['pdf.fonttype'] = 42
        matplotlib.rcParams['ps.fonttype'] = 42

        scaf_to_len = {}
        regions=["exonic", "intronic", "intergenic"]
        with open(input.genfile, "r") as f:
            for line in f:
                line=line.strip()
                if line:
                    splitd = line.split()
                    if int(splitd[1]) > 5000000:
                        scaf_to_len[splitd[0]] = int(splitd[1])

        df = pd.read_csv(input.hbp, header=0, sep='\t', comment='#')
        df = df.loc[df["chrom"].isin([x for x in scaf_to_len]), ]
        df = df.loc[df["region"].isin(regions),]
        df = df.reset_index(drop=True)
        # now figure out the absolute coordinates to use for plotting
        chrom_coords =[]
        df["diff_from_last"] = df["targ_stop"]-df["targ_start"]+1
        prev_chrom = ""
        for i, row in df.iterrows():
            if row["chrom"] != prev_chrom:
                if prev_chrom != "":
                    df.at[i-1,'stop'] = scaf_to_len[df.at[i-1,'chrom']]
                    df.at[i-1,'diff_from_last'] = df.at[i-1,'stop'] - df.at[i-1,'targ_start'] +1
                    if len(chrom_coords) < len(scaf_to_len):
                        chrom_coords.append(i-1)
            prev_chrom = row["chrom"]
        lastpos = len(df)-1
        if len(chrom_coords) < len(scaf_to_len):
            chrom_coords.append(lastpos)
        df.at[lastpos,'diff_from_last'] = df.at[lastpos,'stop'] - df.at[lastpos,'targ_start'] +1

        plot_these_features = ["het", "depth_mean", "per_gc", "per_indel_bases"]
        # Now plot the normalized scaffold N50 and contigN50
        #set the figure dimensions
        single_fig_height = 2
        figWidth = 12

        #set the panel dimensions
        panelWidth = 7
        panelHeight = 1
        #find the margins to center the panel in figure
        leftMargin = (figWidth - panelWidth)/2
        bottomMargin = (single_fig_height - panelHeight)/2
        panel_bottom_pos = bottomMargin

        figHeight = (panelHeight * len(plot_these_features)) + ((len(plot_these_features) + 1)*bottomMargin)
        fig = plt.figure(figsize=(figWidth,figHeight))

        chrom_limits = df.loc[chrom_coords,]
        chrom_limits = chrom_limits.reset_index(drop=True)
        chrom_limits["diff_from_last"]  = chrom_limits["chrom"].apply(lambda x: scaf_to_len[x])
        chrom_limits["absolute_stop"] = chrom_limits["diff_from_last"].cumsum()
        chrom_limits["absolute_start"] = chrom_limits["absolute_stop"] - chrom_limits["stop"] +1
        chrom_limits = chrom_limits[["chrom", "stop", "absolute_stop",
                                     "absolute_start"]]
        chrom_limits["percent_of_panel_width"] = chrom_limits["stop"]/chrom_limits["stop"].sum()
        chrom_limits["panel_width"] = chrom_limits["percent_of_panel_width"] * panelWidth
        margin_width = (figWidth - panelWidth)/(len(chrom_limits) + 4)
        chrom_limits["left_position"] = margin_width
        for i, row in chrom_limits.iterrows():
            if i != 0:
                chrom_limits.at[i,"left_position"] = chrom_limits.at[i-1, "left_position"] + chrom_limits.at[i-1, "panel_width"] + margin_width

        panels = []
        for plot_feature in plot_these_features:
            for i, row in chrom_limits.iterrows():
                loopchrom = row["chrom"]
                thisdf = df.loc[df["chrom"] == loopchrom,]
                panels.append(plt.axes([row["left_position"]/figWidth, #left
                               panel_bottom_pos/figHeight,    #bottom
                               row["panel_width"]/figWidth,   #width
                               panelHeight/figHeight])     #height
                )
                if len(panels) % len(chrom_limits) == 0:
                    panels[-1].tick_params(axis='both',which='both',\
                                  bottom=False, labelbottom=True,\
                                  left=False, labelleft=False, \
                                  right=True, labelright=True,\
                                  top=False, labeltop=False)
                    panels[-1].set_ylabel(plot_feature)
                    panels[-1].yaxis.set_label_position("right")
                    panels[-1].spines['top'].set_visible(False)
                    panels[-1].spines['left'].set_visible(False)
                else:
                    panels[-1].tick_params(axis='both',which='both',\
                          bottom=False, labelbottom=True,\
                          left=False, labelleft=False, \
                          right=False, labelright=False,\
                          top=False, labeltop=False)
                    panels[-1].spines["top"].set_visible(False)
                    panels[-1].spines["left"].set_visible(False)
                    panels[-1].spines["right"].set_visible(False)
                panels[-1].set_xticks([row["stop"]/2])
                panels[-1].set_xticklabels([row["chrom"]])
                panels[-1].set_ylim([min(df[plot_feature]),max(df[plot_feature])*1.05])
                for region_index in range(len(regions)):
                    thisregion = regions[region_index]
                    plotdf = thisdf.loc[thisdf["region"] == thisregion,]
                    plotdf = plotdf.reset_index(drop=True)
                    plotdf["xcoord"] = plotdf["stop"] - (plotdf["diff_from_last"]/2)
                    panels[-1].plot(plotdf["xcoord"],
                                    plotdf[plot_feature],
                                    lw=0.5,
                                    color=region_palette[thisregion],
                                    alpha=0.75)
            panel_bottom_pos = panel_bottom_pos + bottomMargin + panelHeight
        #plt.tight_layout()
        fig.savefig(output.pdf)

rule plot_pairplots:
    """
    makes a large seaborn pairplot to quickly explore all of the variables.
    """
    input:
        hbp = "het_output/final_output/tables/{prefix}_w{window}_indel_snp.tsv"
    output:
        pdf = "het_output/final_output/pdf/pairplot/{prefix}_w{window}_pairplot.pdf",
    threads: 1
    run:
        import seaborn as sns; sns.set()
        import matplotlib
        import matplotlib.pyplot as plt
        import matplotlib.ticker as ticker
        from matplotlib.ticker import StrMethodFormatter, NullFormatter

        # set seaborn stuff
        #sns.set(rc={'text.usetex' : True})
        sns.set_style("white", {'font.family': ['sans-serif'],
                                    'font.sans-serif': ['Helvetica'],
                                    'grid.color': '.95'})

        # Preserve the vertical order of embedded images:
        matplotlib.rcParams['image.composite_image'] = False
        matplotlib.rcParams['pdf.fonttype'] = 42
        matplotlib.rcParams['ps.fonttype'] = 42

        df = pd.read_csv(input.hbp, header=0, sep='\t', comment='#')
        df = df.loc[df["region"].isin(["exonic", "intronic", "intergenic"])]
        df = df.loc[df["chrom"].isin(["c{}".format(x) for x in range(1,14)])]
        ax = sns.pairplot(df, hue="region", palette=region_palette,
                          vars=["het", "per_gc",
                                "VCF_per_SNP", "VCF_per_Indel",
                                "transition_div_transversion",
                                "per_indel_bases", "per_deletion_bases","per_insertion_bases",
                                "per_indel_sites", "per_deletion_sites","per_insertion_sites",
                                ])
        ax.savefig(output.pdf)
